# C++内存管理技术内幕

## 1.1 C++内存管理详解

**内存分为五个区**

1. 堆，用户自己申请、释放。如果没有释放，那么在程序结束后，操作系统会自动回收
2. 栈，执行函数时，函数内局部变量的存储单元都可以在栈上创建，执行结束后存储单元自动释放。栈内存的分配运算内置于处理器的指令集中，效率很高，但是容量很小
3. 自由存储区，由malloc分配的内存块，和堆类似，但是只能用free来释放
4. 全局/静态存储区，全局变量和静态变量被分配到同一块内存中
5. 常量存储区，存放常量，不允许修改

**区分堆和栈**

```c++
void f(){
	int *p = new int[5];
}
```

这段代码中，我们开辟了一个容量为5的int数组，并且由一个int型指针指向它。

其中，数组存储在堆中，因为是我们new出来的，指针p存储在栈中，由系统自动分配。

**堆和栈的主要区别**

1. 管理方式不同：对于栈来说，由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak
2. 空间大小不同：一般来讲，在32位系统下，堆内存可以达到4G的空间（几乎是没有什么限制的），但是对于栈来讲，一般都是有一定的空间大小。
3. 能否产生碎片不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
4. 生长方式不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址见效的方向增长的。
5. 分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配；动态分配由alloc函数进行分配，释放由编译器进行释放
6. 分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，堆是C/C++库函数提供的。堆的效率比栈的效率要低得多

**常见的内存错误及其对策**

+ 内存分配未成功，却使用了它

​		使用该指针之前先判断该指针指向的地址是否为空

+ 内存分配虽然成功，但是尚未初始化就引用它

+ 内存分配成功并且已经初始化，但操作越过了内存的边界

+ 忘记了释放内存，造成内存泄漏

​		确保程序中new/delete次数要相同

+ 释放了内存却继续使用它

  1. 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
  2. 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁
  3. 使用free或delete释放了内存之后，没有将指针设置为NULL，导致产生“野指针”

  

  使用规则

  1. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存
  2. 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
  3. 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作
  4. 动态内存的深情与释放必须配对，防止内存泄漏
  5. 用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”

**有了malloc/free为什么还要new/delete**

malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符。它们都可用于深情动态内存和释放内存。

对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。

那么为什么有了new/delete之后保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

**内存耗尽怎么办**

1. 判断指针是否为NULL，如果是则马上用return语句终止本函数

   ```C++
   void Func(void){
   	A *a = new A;
   	if (a == NULL){
   		return;
   	}
   	...
   }
   ```

   

2. 判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行

   ``````c++
   void Func(void){
   	A *a = new A;
   	if(a == NULL){
   		cout << "Memory Exhausted" << endl;
   		exit(1);
   	}
   	...
   }
   ``````

   

3. 为new和malloc设置异常处理函数。

**malloc/free的使用要点**

函数malloc的原型如下：

```c++
void *malloc(size_t size);
```

用malloc申请一块长度为length的整数类型的内存，程序如下：

```C++
int *p = (int *)malloc(sizeof(int) * length);
```

- malloc返回值的类型是void\*，所以在调用malloc时要显式地进行类型转换，将void\*转换成所需要的指针类型
- malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。

函数free的原型如下：

```c++
void free(void *memblock);
```

4. 杜绝野指针

野指针不是NULL指针，是指向“垃圾”内存的指针。

- 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

  ```c++
  char *p = NULL;
  char *str = (char *)malloc(100);
  ```

- 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针
- 指针操作超越了变量的作用域范围。

## 1.2 C++中的健壮指针和资源管理

**第一条规则（RALL）**

RAII = Resource Acquisition Is Initialization（资源获取即初始化）

基本思想是将资源的获取（如内存分配、文件打开等）与对象的构造绑定在一起，将资源的释放与对象的析构绑定在一起。这样，在对象生命周期结束时，析构函数会自动被调用，从而释放对象所持有的资源。

RAII在C++中广泛用于管理动态分配的内存、文件句柄、互斥锁等资源，通过避免受冻的资源分配和释放来降低错误发生的概率。它也是让代码更具有可读性、可维护性和异常安全性的重要技术。

**智能指针**

用于管理动态分配的内存资源，以防止内存泄漏和资源泄漏

智能指针的主要目标是在对象不再使用时自动释放它所管理的资源，从而减少手动内存管理的复杂性。

1. `std::unique_ptr`：表示唯一的资源所有权。一个`std::unique_str`拥有对其管理的对象的独占所有权。当`std::unique_ptr`离开其作用域时，它将自动释放其所管理的对象。不能拷贝，但可以通过移动语义传递所有权。
2. `std::shared_ptr`：表示共享的资源所有权。多个`std::shared_ptr`可以共享对同一对象的所有权，当最后一个`std::shared_ptr`离开其作用域时，才会释放其所管理的对象。它使用引用计数器来追踪所有者数。可以通过拷贝来共享所有权。
3. `std::weak_ptr`：也用于共享资源所有权，但不会增加引用计数。`std::weak_ptr`允许共享资源，但不会延长资源的生命周期。它通常用于避免循环引用问题，比如在使用共享指针的环境下避免内存泄漏。

**Resource Transfer**

指在编程中将资源所有权从一个对象或实体转移到另一个对象或实体店过程。这种转移通常涉及资源的创建、分配、释放或所有权的移交，以确保资源的正确管理和释放，从而避免资源泄漏和错误。

在C++中，使用移动语义和右值引用可以实现资源的高效转移。移动语义允许对象在传递所有权时不进行资源的深拷贝，而是将资源的控制权转移到新对象上，从而提高效率。这在容器类中尤其有用，因为容器的元素在进行扩容或插入操作时可能需要频繁地进行资源转移。

```c++
#include <iostream>
#include <string>

class Resource{
public:
    Resource(const std::string& data) : data_(data){
        std::cout << "Resource acquired: " << data_ << std::endl;
    }

    ~Resource(){
        std::cout << "Resource released: " << data_ << std::endl;
    }
private:
    std::string data_;
};

int main(){
    Resource originalResource("Original Data");

    Resource transferredResource = std::move(originalResource);

    return 0;
}
```

在这个示例中，通过使用`std::move()`函数，`transferredResource`获得了`originalResource`的资源所有权。当`originalResource`离开作用域时，析构函数并不会释放资源，因为资源已经在转移时交给了`transferredResource`，而`transferredResource`在离开作用域时会负责释放资源。

## 内存泄漏

内存泄漏是指在计算机程序中未正确释放或回收已分配的动态内存，导致程序持续占用内存而释放，最终导致程序的内存消耗不断增加。

以下是内存泄漏的一些常见情况和原因：

1. 未释放分配的内存：程序分配了内存（例如使用了`new`、`malloc`等操作符或函数），但在不再需要该内存时未释放它。这会导致分配的内存无法再被使用，最终占用系统内存。
2. 失去了指向内存的指针：有时程序可能会丢失指向动态分配内存的指针，这意味着程序无法再访问或释放该内存。
3. 循环引用：在某些情况下，对象之间的循环引用可能导致内存泄漏。例如，在使用C++的智能指针时，如果两个对象相互持有对方的`shared_ptr`，它们之间可能形成循环引用，导致内存泄漏。
4. 资源未释放：内存泄漏不仅限于堆内存，还可以涉及文件句柄、网络连接、数据库连接等资源。如果程序未正确关闭或释放这些资源，将导致资源泄漏。

如何对付内存泄漏

